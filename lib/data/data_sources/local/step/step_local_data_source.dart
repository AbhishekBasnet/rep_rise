import 'package:drift/drift.dart';
import 'package:flutter/foundation.dart';
import 'package:rep_rise/data/model/steps/step_model.dart';

part 'step_local_data_source.g.dart';

/// Defines the local schema for storing daily step counts.
///
/// This table uses [date] as the primary key to ensure we only have
/// one record per day. The [goal] defaults to 0 if not provided.
class Steps extends Table {
  DateTimeColumn get date => dateTime()();
  IntColumn get steps => integer()();
  IntColumn get goal => integer().withDefault(const Constant(0))();
  TextColumn get dayName => text().nullable()();

  @override
  Set<Column> get primaryKey => {date};
}

/// The main database entry point for the application.
///
/// Handles the connection to the underlying SQLite database and manages
/// schema migrations. This class is generated by Drift.
@DriftDatabase(tables: [Steps])
class AppDatabase extends _$AppDatabase {
  AppDatabase(QueryExecutor e) : super(e);

  @override
  int get schemaVersion => 3;

  /*
   * MIGRATION STRATEGY
   *
   * This section defines how the database handles schema upgrades when the
   * [schemaVersion] is incremented.
   *
   * LOGIC FOR VERSION 3:
   * We are currently in a development phase where schema conflicts (specifically
   * regarding the removal of the old 'id' column) are resolved by performing
   * a destructive migration.
   *
   *TODO: Implement proper migration logic before production release.
   * ! WARNING:
   * This logic deletes the 'steps' table and recreates it, resulting in total
   * local data loss. For production releases, implement proper SQL ALTER statements
   * or custom Drift migration logic to preserve user data.
   */
  @override
  MigrationStrategy get migration => MigrationStrategy(
    onUpgrade: (Migrator m, int from, int to) async {
      debugPrint("Drift Migration: Upgrading from $from to $to");

      if (from < 3) {
        debugPrint("Recreating 'steps' table to resolve schema conflict...");
        await m.deleteTable(steps.actualTableName);
        await m.createTable(steps);
      }
    },
    beforeOpen: (details) async {
      await customStatement('PRAGMA foreign_keys = ON');
    },
  );
}

/// Contract for accessing step data from local storage.
abstract class StepLocalDataSource {
  Future<List<Step>> getCachedSteps();
  Future<void> cacheSteps(List<StepModel> steps);
  Future<void> deleteAllSteps();
}

/// Implementation of [StepLocalDataSource] using Drift as the ORM.
///
/// This layer abstracts the direct database calls, allowing for easier
/// testing and potential database swaps in the future without breaking
/// the repository layer.
class StepLocalDataSourceImpl implements StepLocalDataSource {
  final AppDatabase db;

  StepLocalDataSourceImpl({required this.db});

  @override
  Future<List<Step>> getCachedSteps() {
    return db.select(db.steps).get();
  }

  /// Batch inserts a list of steps.
  ///
  /// Uses [InsertMode.insertOrReplace] to ensure that if data for a specific
  /// date already exists, it is updated with the latest server data rather
  /// than throwing a constraint error.
  @override
  Future<void> cacheSteps(List<StepModel> steps) async {
    await db.batch((batch) {
      batch.insertAll(
        db.steps,
        steps
            .map(
              (s) =>
                  StepsCompanion.insert(date: s.date, steps: s.steps, goal: Value(s.goal), dayName: Value(s.dayName)),
            )
            .toList(),
        mode: InsertMode.insertOrReplace,
      );
    });
  }

  @override
  Future<void> deleteAllSteps() {
    return db.delete(db.steps).go();
  }
}
